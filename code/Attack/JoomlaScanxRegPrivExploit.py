import logging
import random as rnd
import lea
import scapy.layers.inet as inet
import scapy.utils
import Attack.BaseAttack as BaseAttack
import Lib.Utility as Util
from Attack.Parameter import Parameter, Float, IPAddress, MACAddress, Port
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)

class JoomlaScanxRegPrivExploit(BaseAttack.BaseAttack):
    template_scan_pcap_path = Util.RESOURCE_DIR + "Joomla_Scan_x_RegPrivEsc.pcap"
    PORT_SOURCE = 'port.src'
    PORT_DESTINATION = 'port.dst'
    TIME_BETWEEN_STAGES = 'time.between.stages'
    my_sql_port = 3306
    attacker_ip = '192.168.137.233' 
    victim_ip = '52.113.199.40'
    mysql_port = '52.113.199.199'

    """
    Creates a new instance of the Joomla Scan followed by Joomla Registeration Privileges Escalation Exploit
    """
    def __init__(self):
        # Initialize attack
        super(JoomlaScanxRegPrivExploit, self).__init__("JoomlaScanxRegPrivExploit", 
                                                        "Injects a Joomla Scan followed by a JoomlaRegPrivesc exploit'",
                                                        "Multistage: Scanning/Probing + Privilege escalation")

        # Define allowed parameters and their type
        self.update_params([
            Parameter(self.MAC_SOURCE, MACAddress()),
            Parameter(self.MAC_DESTINATION, MACAddress()),
            Parameter(self.IP_SOURCE, IPAddress()),
            Parameter(self.IP_DESTINATION, IPAddress()),
            Parameter(self.PORT_SOURCE, Port()),
            Parameter(self.PORT_DESTINATION, Port()),
            Parameter(self.PACKETS_PER_SECOND, Float()),
            Parameter(self.TIME_BETWEEN_STAGES, Float())
        ])

    """
    Initialize a parameter with its default values specified in this attack.

    :param param: parameter, which should be initialized
    :return: True if initialization was successful, False if not
    """
    def init_param(self, param: str) -> bool:
        value = None
        if param == self.MAC_SOURCE:
            ip_src = self.get_param_value(self.IP_SOURCE)
            if ip_src is None:
                return False
            value = self.get_mac_address(ip_src)
        elif param == self.MAC_DESTINATION:
            ip_dst = self.get_param_value(self.IP_DESTINATION)
            if ip_dst is None:
                return False
            value = self.get_mac_address(ip_dst)
        elif param == self.IP_SOURCE:
            ip_dst = self.get_param_value(self.IP_DESTINATION)
            if ip_dst is None:
                return False
            value = self.statistics.get_random_ip_address(ips=[ip_dst])
        elif param == self.IP_DESTINATION:
            value = self.statistics.get_most_used_ip_address()
        elif param == self.PORT_DESTINATION:
            value = 80 # HTTP
        elif param == self.PORT_SOURCE:
            value = self.get_param_value(self.PORT_SOURCE)
        elif param == self.PACKETS_PER_SECOND:
            value = self.statistics.get_most_used_pps()
        elif param == self.INJECT_AFTER_PACKET:
            value = rnd.randint(0, self.statistics.get_packet_count())
        elif param == self.TIME_BETWEEN_STAGES:
            value = 0
        if value is None:
            return False
        return self.add_param_value(param, value)

    """
    Generate SQL convo parameters 
    """
    def generate_sql_param(self): 
        ip_addresses_in_use = self.statistics.get_ip_addresses()
        ip_attakcer = self.get_param_value(self.IP_DESTINATION)
        subnet_mask = "255.255.255.0"
        ip_sql = self.get_unique_random_ipv4_from_ip_network(ip_attakcer, subnet_mask,ip_addresses_in_use)
        mac_sql = self.generate_random_mac_address() 
        return mac_sql, ip_sql

    """
    Creates the attack packets
    """
    def generate_attack_packets(self):

        # Timestamp
        timestamp_next_pkt = self.get_param_value(self.INJECT_AT_TIMESTAMP)

        # Initialize parameters
        mac_source = self.get_param_value(self.MAC_SOURCE)
        mac_destination = self.get_param_value(self.MAC_DESTINATION)
        ip_source = self.get_param_value(self.IP_SOURCE)
        ip_destination = self.get_param_value(self.IP_DESTINATION)
        port_destination = self.get_param_value(self.PORT_DESTINATION)
        time_between_stages = self.get_param_value(self.TIME_BETWEEN_STAGES)

        # Check ip.src == ip.dst
        self.ip_src_dst_catch_equal(ip_source, ip_destination)

        # Set TTL based on TTL distribution of IP address
        source_ttl_dist = self.statistics.get_ttl_distribution(ip_source)
        if len(source_ttl_dist) > 0:
            source_ttl_prob_dict = lea.Lea.fromValFreqsDict(source_ttl_dist)
            source_ttl_value = source_ttl_prob_dict.random()
        else:
            source_ttl_value = Util.handle_most_used_outputs(self.statistics.get_most_used_ttl_value())

        destination_ttl_dist = self.statistics.get_ttl_distribution(ip_destination)
        if len(destination_ttl_dist) > 0:
            destination_ttl_prob_dict = lea.Lea.fromValFreqsDict(destination_ttl_dist)
            destination_ttl_value = destination_ttl_prob_dict.random()
        else:
            destination_ttl_value = Util.handle_most_used_outputs(
                self.statistics.get_most_used_ttl_value())

        # Set Window Size based on Window Size distribution of IP address
        source_win_dist = self.statistics.get_win_distribution(ip_source)
        if len(source_win_dist) > 0:
            source_win_prob_dict = lea.Lea.fromValFreqsDict(source_win_dist)
        else:
            source_win_dist = self.statistics.get_win_distribution(self.statistics.get_most_used_ip_address())
            source_win_prob_dict = lea.Lea.fromValFreqsDict(source_win_dist)

        destination_win_dist = self.statistics.get_win_distribution(ip_destination)
        if len(destination_win_dist) > 0:
            destination_win_prob_dict = lea.Lea.fromValFreqsDict(destination_win_dist)
        else:
            destination_win_dist = self.statistics.get_win_distribution(self.statistics.get_most_used_ip_address())
            destination_win_prob_dict = lea.Lea.fromValFreqsDict(destination_win_dist)

        # Set MSS (Maximum Segment Size) based on MSS distribution of IP address
        mss_value = Util.handle_most_used_outputs(self.statistics.get_most_used_mss_value())
        if not mss_value:
            mss_value = 1465

        # Communication is between server & its db
        mac_sql, ip_sql = self.generate_sql_param()

        exploit_raw_packets = scapy.utils.RawPcapReader(self.template_scan_pcap_path)
        inter_arrival_times = self.get_inter_arrival_time(exploit_raw_packets)
        exploit_raw_packets.close()
        exploit_raw_packets = scapy.utils.RawPcapReader(self.template_scan_pcap_path)

        source_origin_wins, destination_origin_wins = {}, {}
        ephemeral_ports = {}
        reserved_ports = {self.my_sql_port, port_destination}

        # Random TCP sequence numbers
        global attacker_seq
        attacker_seq = rnd.randint(1000, 50000)
        global victim_seq
        victim_seq = rnd.randint(1000, 50000)

        original_time_difference_between_stages = 68.4
        stage_1 = True
        arrival_time = 0
        for self.pkt_num, pkt in enumerate(exploit_raw_packets):
            eth_frame = inet.Ether(pkt[0])
            ip_pkt = eth_frame.payload
            tcp_pkt = ip_pkt.payload
            str_tcp_seg = str(tcp_pkt.payload)
            ep, ephemeral_ports = self.generate_ephemeral_ports(tcp_pkt, ephemeral_ports, reserved_ports)
            arrival_time = arrival_time + inter_arrival_times[self.pkt_num]
            
            # At this point - the second stage of the attack is initiating
            if self.pkt_num == 420:
                stage_1 = False

            if stage_1 == False:
                # Clean payloads
                eth_frame.payload = inet.NoPayload()
                ip_pkt.payload = inet.NoPayload()
                tcp_pkt.payload = inet.NoPayload()

            # Request (Attacker -> Victim)
            if ip_pkt.getfieldval("src") == self.attacker_ip:
                # Ether
                eth_frame.setfieldval("src", mac_source)
                eth_frame.setfieldval("dst", mac_destination)
                # IP
                ip_pkt.setfieldval("src", ip_source)
                ip_pkt.setfieldval("dst", ip_destination)
                ip_pkt.setfieldval("ttl", source_ttl_value)
                # TCP
                tcp_pkt.setfieldval("sport", ep)
                tcp_pkt.setfieldval("dport", port_destination)

                # JoomlaRegPrivExploit: Reply (Victim -> Attacker)
                if stage_1 == False:
                    str_tcp_seg = self.modify_http_header(str_tcp_seg, '/joomla360', "/", self.victim_ip, "www.hackme.com")
                    # TCP Seq, Ack
                    if tcp_pkt.getfieldval("ack") != 0:
                        tcp_pkt.setfieldval("ack", victim_seq)
                    tcp_pkt.setfieldval("seq", attacker_seq)
                    # flags = A
                    if not (tcp_pkt.getfieldval("flags") == 16 and len(str_tcp_seg) == 0):
                        attacker_seq += max(len(str_tcp_seg), 1)

                # Window Size (mapping)
                source_origin_win = tcp_pkt.getfieldval("window")
                if source_origin_win not in source_origin_wins:
                    while True: 
                        source_win_rand_pick = source_win_prob_dict.random()
                        if source_win_rand_pick != 0: 
                            break
                    source_origin_wins[source_origin_win] = source_win_rand_pick
                new_win = source_origin_wins[source_origin_win]
                tcp_pkt.setfieldval("window", new_win)
                # MSS
                tcp_options = tcp_pkt.getfieldval("options")
                if tcp_options:
                    if tcp_options[0][0] == "MSS":
                        tcp_options[0] = ("MSS", mss_value)
                        tcp_pkt.setfieldval("options", tcp_options)

            # Request (DB ->  Victim/WebApp)
            elif ip_pkt.getfieldval("src") == self.mysql_port:
                eth_frame.setfieldval("src", mac_sql)         
                ip_pkt.setfieldval("src", ip_sql)
                tcp_pkt.setfieldval("sport", self.my_sql_port)  
                eth_frame.setfieldval("dst", mac_destination)      
                ip_pkt.setfieldval("dst", ip_destination)
                tcp_pkt.setfieldval("dport", ep)

            # Reply (Victim -> Attacker or DB)
            else: 
                eth_frame.setfieldval("src", mac_destination)         
                ip_pkt.setfieldval("src", ip_destination)
                # Reply (Victim -> DB)
                if ip_pkt.getfieldval("dst") == self.mysql_port:
                    eth_frame.setfieldval("dst", mac_sql)
                    ip_pkt.setfieldval("dst", ip_sql)
                    tcp_pkt.setfieldval("sport", ep)
                    tcp_pkt.setfieldval("dport", self.my_sql_port)
                    
                # Reply (Victim -> Attack)
                else:
                    eth_frame.setfieldval("dst", mac_source)
                    ip_pkt.setfieldval("dst", ip_source)
                    ip_pkt.setfieldval("ttl", destination_ttl_value)
                    tcp_pkt.setfieldval("sport",  port_destination)
                    tcp_pkt.setfieldval("dport", ep)
                    
                    # JoomlaRegPrivExploit: Reply (Victim -> Attacker)
                    if stage_1 == False:
                        str_tcp_seg = self.modify_http_header(str_tcp_seg, '/joomla360', "/", self.victim_ip, "www.hackme.com")                        # TCP Seq, ACK
                        tcp_pkt.setfieldval("ack", attacker_seq)
                        tcp_pkt.setfieldval("seq", victim_seq)
                        str_len = len(str_tcp_seg)
                        # flags = A
                        if not (tcp_pkt.getfieldval("flags") == 16 and str_len == 0):
                            victim_seq += max(str_len, 1)
                    
                    # Window Size (mapping)
                    destination_origin_win = tcp_pkt.getfieldval("window")
                    if destination_origin_win not in destination_origin_wins:
                        while True:
                            destination_win_rand_pick = destination_win_prob_dict.random()
                            if destination_win_rand_pick != 0:
                                break
                        destination_origin_wins[destination_origin_win] = destination_win_rand_pick
                    new_win = destination_origin_wins[destination_origin_win]
                    tcp_pkt.setfieldval("window", new_win)
                    # MSS
                    tcp_options = tcp_pkt.getfieldval("options")
                    if tcp_options:
                        if tcp_options[0][0] == "MSS":
                            tcp_options[0] = ("MSS", mss_value)
                            tcp_pkt.setfieldval("options", tcp_options)

            # Generate packet based on stage in attack
            if stage_1 == True: 
                new_pkt = (eth_frame / ip_pkt / tcp_pkt)
                new_pkt.time = timestamp_next_pkt + arrival_time
                timestamp_next_pkt = self.timestamp_controller.next_timestamp()
            else:
                new_pkt = (eth_frame / ip_pkt / tcp_pkt / str_tcp_seg)
                new_pkt.time = timestamp_next_pkt + arrival_time + time_between_stages - original_time_difference_between_stages
                timestamp_next_pkt = self.timestamp_controller.next_timestamp()
            self.add_packet(new_pkt, ip_source, ip_destination)
        exploit_raw_packets.close()

    """
    Creates a pcap containing the attack packets.

    :return: The location of the generated pcap file.
    """
    def generate_attack_pcap(self):
        # Store timestamp of first packet (for attack label)
        self.attack_start_utime = self.packets[0].time
        self.attack_end_utime = self.packets[-1].time

        if len(self.packets) > 0:
            self.packets = sorted(self.packets, key=lambda pkt: pkt.time)
            self.path_attack_pcap = self.write_attack_pcap(self.packets, True, self.path_attack_pcap)

        # return packets sorted by packet time_sec_start
        # pkt_num+1: because pkt_num starts at 0
        return self.pkt_num + 1, self.path_attack_pcap